1. Write a program to demonstrate singly linked list with following operations
Create, Insert, Delete, Display, Reverse
 
class Node {
constructor(data) {
this.data = data;
this.next = null;
}
}
 
class SinglyLinkedList {
constructor() {
this.head = null;
}
 
// Create a new node and add it to the end of the list
insert(data) {
const newNode = new Node(data);
if (!this.head) {
this.head = newNode;
} else {
let current = this.head;
while (current.next) {
current = current.next;
}
current.next = newNode;
}
}
 
// Display the linked list
display() {
let current = this.head;
while (current) {
console.log(current.data);
current = current.next;
}
}
 
// Delete a node with a specific data value
delete(data) {
if (!this.head) return;
 
if (this.head.data === data) {
this.head = this.head.next;
return;
}
 
let current = this.head;
while (current.next) {
if (current.next.data === data) {
current.next = current.next.next;
return;
}
current = current.next;
}
}
 
// Reverse the linked list
reverse() {
let prev = null;
let current = this.head;
let next = null;
 
while (current) {
next = current.next;
current.next = prev;
prev = current;
current = next;
}
 
this.head = prev;
}
}
 
const myList = new SinglyLinkedList();
myList.insert(1);
myList.insert(2);
myList.insert(3);
 
console.log("Original List:");
myList.display();
 
myList.delete(2);
console.log("\nList after deleting 2:");
myList.display();
 
myList.reverse();
console.log("\nReversed List:");
myList.display();
 
 
2. Write a program to demonstrate doubly linked list with following operations
Create, Insert, Delete, Display
 
class Node {
constructor(data) {
this.data = data;
this.prev = null;
this.next = null;
}
}
 
class DoublyLinkedList {
constructor() {
this.head = null;
}
 
// Create a new node and add it to the end of the list
insert(data) {
const newNode = new Node(data);
if (!this.head) {
this.head = newNode;
} else {
let current = this.head;
while (current.next) {
current = current.next;
}
current.next = newNode;
newNode.prev = current;
}
}
 
// Display the doubly linked list
display() {
let current = this.head;
while (current) {
console.log(current.data);
current = current.next;
}
}
 
// Delete a node with a specific data value
delete(data) {
if (!this.head) return;
 
if (this.head.data === data) {
this.head = this.head.next;
if (this.head) {
this.head.prev = null;
}
return;
}
 
let current = this.head;
while (current) {
if (current.data === data) {
if (current.prev) {
current.prev.next = current.next;
}
if (current.next) {
current.next.prev = current.prev;
}
return;
}
current = current.next;
}
}
}
 
// Example usage:
const myList = new DoublyLinkedList();
myList.insert(1);
myList.insert(2);
myList.insert(3);
 
console.log("Original List:");
myList.display();
 
myList.delete(2);
console.log("\nList after deleting 2:");
myList.display();
 
 
3. Write a program to implement STACK using linked list with PUSH, POP and
DISPLAY operations
 
class Node {
constructor(data) {
this.data = data;
this.next = null;
}
}
 
class Stack {
constructor() {
this.top = null;
this.size = 0;
}
 
// PUSH operation to add an element to the top of the stack
push(data) {
const newNode = new Node(data);
newNode.next = this.top;
this.top = newNode;
this.size++;
}
 
// POP operation to remove and return the element from the top of the stack
pop() {
if (!this.top) {
console.log("Stack is empty.");
return null;
}
 
const data = this.top.data;
this.top = this.top.next;
this.size--;
return data;
}
 
// DISPLAY operation to print the elements of the stack
display() {
let current = this.top;
while (current) {
console.log(current.data);
current = current.next;
}
}
}
 
// Example usage:
const myStack = new Stack();
 
myStack.push(1);
myStack.push(2);
myStack.push(3);
 
console.log("Stack after PUSH operations:");
myStack.display();
 
const poppedItem = myStack.pop();
console.log("\nPopped item:", poppedItem);
 
console.log("\nStack after POP operation:");
myStack.display();
 
 
4. Write a program to implement Linear Queue using linked list with INSERT,
DELETE and DISPLAY operations
 
class Node {
constructor(data) {
this.data = data;
this.next = null;
}
}
 
class LinearQueue {
constructor() {
this.front = null;
this.rear = null;
}
 
// INSERT operation to enqueue an element
insert(data) {
const newNode = new Node(data);
if (!this.rear) {
this.front = newNode;
this.rear = newNode;
} else {
this.rear.next = newNode;
this.rear = newNode;
}
}
 
// DELETE operation to dequeue an element
delete() {
if (!this.front) {
console.log("Queue is empty.");
return null;
}
 
const data = this.front.data;
this.front = this.front.next;
if (!this.front) {
this.rear = null; // Reset rear when the queue becomes empty
}
return data;
}
 
// DISPLAY operation to print the elements of the queue
display() {
let current = this.front;
while (current) {
console.log(current.data);
current = current.next;
}
}
}
 
// Example usage:
const myQueue = new LinearQueue();
 
myQueue.insert(1);
myQueue.insert(2);
myQueue.insert(3);
 
console.log("Queue after INSERT operations:");
myQueue.display();
 
const dequeuedItem = myQueue.delete();
console.log("\nDequeued item:", dequeuedItem);
 
console.log("\nQueue after DELETE operation:");
myQueue.display();
 
 
5. Write a program to implement Circular Queue using linked list with INSERT,
DELETE and DISPLAY operations
 
class Node {
constructor(data) {
this.data = data;
this.next = null;
}
}
 
class CircularQueue {
constructor() {
this.front = null;
this.rear = null;
}
 
// INSERT operation to enqueue an element
insert(data) {
const newNode = new Node(data);
if (!this.rear) {
this.front = newNode;
this.rear = newNode;
} else {
this.rear.next = newNode;
this.rear = newNode;
}
this.rear.next = this.front; // Make the queue circular
}
 
// DELETE operation to dequeue an element
delete() {
if (!this.front) {
console.log("Queue is empty.");
return null;
}
 
const data = this.front.data;
if (this.front === this.rear) {
this.front = null;
this.rear = null;
} else {
this.front = this.front.next;
this.rear.next = this.front; // Update rear's next to maintain circular structure
}
return data;
}
 
// DISPLAY operation to print the elements of the queue
display() {
if (!this.front) {
console.log("Queue is empty.");
return;
}
 
let current = this.front;
do {
console.log(current.data);
current = current.next;
} while (current !== this.front);
}
}
 
// Example usage:
const myCircularQueue = new CircularQueue();
 
myCircularQueue.insert(1);
myCircularQueue.insert(2);
myCircularQueue.insert(3);
 
console.log("Circular Queue after INSERT operations:");
myCircularQueue.display();
 
const dequeuedItem = myCircularQueue.delete();
console.log("\nDequeued item:", dequeuedItem);
 
console.log("\nCircular Queue after DELETE operation:");
myCircularQueue.display();
 
 
6. Write a program to implement Priority Queue using linked list with INSERT,
DELETE and DISPLAY
 
class Node {
constructor(data, priority) {
this.data = data;
this.priority = priority;
this.next = null;
}
}
 
class PriorityQueue {
constructor() {
this.front = null;
}
 
// INSERT operation to enqueue an element with priority
insert(data, priority) {
const newNode = new Node(data, priority);
if (!this.front || priority < this.front.priority) {
newNode.next = this.front;
this.front = newNode;
} else {
let current = this.front;
while (current.next && priority >= current.next.priority) {
current = current.next;
}
newNode.next = current.next;
current.next = newNode;
}
}
 
// DELETE operation to dequeue the highest priority element
delete() {
if (!this.front) {
console.log("Queue is empty.");
return null;
}
 
const data = this.front.data;
this.front = this.front.next;
return data;
}
 
// DISPLAY operation to print the elements of the queue
display() {
let current = this.front;
while (current) {
console.log(`Data: ${current.data}, Priority: ${current.priority}`);
current = current.next;
}
}
}
 
// Example usage:
const myPriorityQueue = new PriorityQueue();
 
myPriorityQueue.insert("Task 1", 2);
myPriorityQueue.insert("Task 2", 1);
myPriorityQueue.insert("Task 3", 3);
 
console.log("Priority Queue after INSERT operations:");
myPriorityQueue.display();
 
const dequeuedItem = myPriorityQueue.delete();
console.log("\nDequeued item:", dequeuedItem);
 
console.log("\nPriority Queue after DELETE operation:");
myPriorityQueue.display();
 
 
7. Write a program to Reverse a string using stack
 
class Stack {
constructor() {
this.items = [];
}
 
push(item) {
this.items.push(item);
}
 
pop() {
if (this.isEmpty()) {
return null;
}
return this.items.pop();
}
 
isEmpty() {
return this.items.length === 0;
}
}
 
function reverseString(input) {
const stack = new Stack();
for (let i = 0; i < input.length; i++) {
stack.push(input[i]);
}
 
let reversedString = '';
while (!stack.isEmpty()) {
reversedString += stack.pop();
}
 
return reversedString;
}
 
const inputString = 'Hello, World!';
const reversed = reverseString(inputString);
console.log('Original string:', inputString);
console.log('Reversed string:', reversed);
 
 
 
8. Write a program to check for balanced parentheses of an expression by using
stacks
 
class Stack {
constructor() {
this.items = [];
}
 
push(item) {
this.items.push(item);
}
 
pop() {
if (this.isEmpty()) {
return null;
}
return this.items.pop();
}
 
isEmpty() {
return this.items.length === 0;
}
}
 
function isBalanced(expression) {
const stack = new Stack();
 
for (let i = 0; i < expression.length; i++) {
const char = expression[i];
 
if (char === '(' || char === '[' || char === '{') {
stack.push(char);
} else if (char === ')' || char === ']' || char === '}') {
const top = stack.pop();
 
if (
(char === ')' && top !== '(') ||
(char === ']' && top !== '[') ||
(char === '}' && top !== '{')
) {
return false; // Unbalanced
}
}
}
 
return stack.isEmpty(); // If the stack is empty, it's balanced
}
 
const expression1 = "((a + b) * (c - d))"; // Balanced
const expression2 = "{[a + b] * (c - d)}"; // Balanced
const expression3 = "(a + b) * (c - d))"; // Unbalanced
 
console.log(`Expression 1 is balanced: ${isBalanced(expression1)}`);
console.log(`Expression 2 is balanced: ${isBalanced(expression2)}`);
console.log(`Expression 3 is balanced: ${isBalanced(expression3)}`);
 
 
 
9. Write a program to reverse stack using queue
class Queue {
constructor() {
this.items = [];
}
 
enqueue(item) {
this.items.push(item);
}
 
dequeue() {
if (this.isEmpty()) {
return null;
}
return this.items.shift();
}
 
isEmpty() {
return this.items.length === 0;
}
 
size() {
return this.items.length;
}
}
 
class Stack {
constructor() {
this.queue1 = new Queue();
this.queue2 = new Queue();
}
 
push(item) {
this.queue1.enqueue(item);
}
 
pop() {
if (this.isEmpty()) {
return null;
}
 
while (this.queue1.size() > 1) {
this.queue2.enqueue(this.queue1.dequeue());
}
 
const poppedItem = this.queue1.dequeue();
 
// Swap the queues
const temp = this.queue1;
this.queue1 = this.queue2;
this.queue2 = temp;
 
return poppedItem;
}
 
isEmpty() {
return this.queue1.isEmpty();
}
}
 
// Example usage:
const myStack = new Stack();
 
myStack.push(1);
myStack.push(2);
myStack.push(3);
 
console.log("Original Stack:");
while (!myStack.isEmpty()) {
console.log(myStack.pop());
}
 
myStack.push(1);
myStack.push(2);
myStack.push(3);
 
console.log("\nReversed Stack:");
myStack.pop(); // Discard the top element
while (!myStack.isEmpty()) {
console.log(myStack.pop());
}
 
 
 
10.Write a program to implement binary search tree with its operations.
 
class Node {
constructor(data) {
this.data = data;
this.left = null;
this.right = null;
}
}
 
class BinarySearchTree {
constructor() {
this.root = null;
}
 
insert(data) {
const newNode = new Node(data);
if (!this.root) {
this.root = newNode;
} else {
this.insertNode(this.root, newNode);
}
}
 
insertNode(node, newNode) {
if (newNode.data < node.data) {
if (!node.left) {
node.left = newNode;
} else {
this.insertNode(node.left, newNode);
}
} else {
if (!node.right) {
node.right = newNode;
} else {
this.insertNode(node.right, newNode);
}
}
}
 
search(data) {
return this.searchNode(this.root, data);
}
 
searchNode(node, data) {
if (!node) {
return false;
}
 
if (data < node.data) {
return this.searchNode(node.left, data);
} else if (data > node.data) {
return this.searchNode(node.right, data);
} else {
return true; // Found the data
}
}
 
inOrderTraversal(callback) {
this.inOrderTraversalNode(this.root, callback);
}
 
inOrderTraversalNode(node, callback) {
if (node) {
this.inOrderTraversalNode(node.left, callback);
callback(node.data);
this.inOrderTraversalNode(node.right, callback);
}
}
}
 
// Example usage:
const myBST = new BinarySearchTree();
 
myBST.insert(5);
myBST.insert(3);
myBST.insert(8);
myBST.insert(1);
myBST.insert(4);
myBST.insert(7);
myBST.insert(9);
 
console.log("In-order traversal of the BST:");
myBST.inOrderTraversal((data) => {
console.log(data);
});
 
const searchValue = 7;
console.log(`Search for ${searchValue}: ${myBST.search(searchValue)}`);
 
 
 
11.Write a program to implement graph traversals.
 
class Graph {
constructor() {
this.adjacencyList = new Map();
}
 
addVertex(vertex) {
if (!this.adjacencyList.has(vertex)) {
this.adjacencyList.set(vertex, []);
}
}
 
addEdge(vertex1, vertex2) {
this.adjacencyList.get(vertex1).push(vertex2);
this.adjacencyList.get(vertex2).push(vertex1);
}
 
depthFirstSearch(startingNode, callback) {
const visited = new Set();
this.dfsRecursive(startingNode, visited, callback);
}
 
dfsRecursive(node, visited, callback) {
visited.add(node);
callback(node);
 
for (const neighbor of this.adjacencyList.get(node)) {
if (!visited.has(neighbor)) {
this.dfsRecursive(neighbor, visited, callback);
}
}
}
 
breadthFirstSearch(startingNode, callback) {
const visited = new Set();
const queue = [startingNode];
visited.add(startingNode);
 
while (queue.length > 0) {
const node = queue.shift();
callback(node);
 
for (const neighbor of this.adjacencyList.get(node)) {
if (!visited.has(neighbor)) {
visited.add(neighbor);
queue.push(neighbor);
}
}
}
}
}
 
// Example usage:
const myGraph = new Graph();
 
myGraph.addVertex('A');
myGraph.addVertex('B');
myGraph.addVertex('C');
myGraph.addVertex('D');
myGraph.addVertex('E');
myGraph.addVertex('F');
 
myGraph.addEdge('A', 'B');
myGraph.addEdge('A', 'C');
myGraph.addEdge('B', 'D');
myGraph.addEdge('C', 'E');
myGraph.addEdge('D', 'E');
myGraph.addEdge('D', 'F');
myGraph.addEdge('E', 'F');
 
console.log("Depth-First Search:");
myGraph.depthFirstSearch('A', (node) => {
console.log(node);
});
 
console.log("\nBreadth-First Search:");
myGraph.breadthFirstSearch('A', (node) => {
console.log(node);
});
 
 
 
12.Write a program to implement linear search.
 
function linearSearch(arr, target) {
for (let i = 0; i < arr.length; i++) {
if (arr[i] === target) {
return i; // Return the index if the target is found
}
}
return -1; // Return -1 if the target is not found
}
 
// Example usage:
const array = [4, 2, 7, 1, 9, 6, 8];
const targetValue = 7;
 
const result = linearSearch(array, targetValue);
 
if (result !== -1) {
console.log(`Found ${targetValue} at index ${result}`);
} else {
console.log(`${targetValue} not found in the array`);
}
 
 
 
13.Write a program to implement binary search.
 
function binarySearch(arr, target) {
let left = 0;
let right = arr.length - 1;
 
while (left <= right) {
const mid = Math.floor((left + right) / 2);
 
if (arr[mid] === target) {
return mid; // Return the index if the target is found
}
 
if (arr[mid] < target) {
left = mid + 1; // Adjust the search range to the right half
} else {
right = mid - 1; // Adjust the search range to the left half
}
}
 
return -1; // Return -1 if the target is not found
}
 
// Example usage:
const sortedArray = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const targetValue = 6;
 
const result = binarySearch(sortedArray, targetValue);
 
if (result !== -1) {
console.log(`Found ${targetValue} at index ${result}`);
} else {
console.log(`${targetValue} not found in the array`);
}
 
 
 
14.Write a program to implement Rain Terrace problem.
 
function trapRainWater(height) {
if (!height || height.length < 3) {
return 0; // Not enough bars to trap water
}
 
const n = height.length;
const leftMax = new Array(n).fill(0);
const rightMax = new Array(n).fill(0);
 
leftMax[0] = height[0];
rightMax[n - 1] = height[n - 1];
 
// Calculate the maximum height to the left of each bar
for (let i = 1; i < n; i++) {
leftMax[i] = Math.max(leftMax[i - 1], height[i]);
}
 
// Calculate the maximum height to the right of each bar
for (let i = n - 2; i >= 0; i--) {
rightMax[i] = Math.max(rightMax[i + 1], height[i]);
}
 
let trappedWater = 0;
 
for (let i = 0; i < n; i++) {
trappedWater += Math.min(leftMax[i], rightMax[i]) - height[i];
}
 
return trappedWater;
}
 
// Example usage:
const height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1];
const trappedWater = trapRainWater(height);
console.log(`Trapped water: ${trappedWater} units`);
 
 
 
15.Write a program to implement Recursive Staircase problem
 
function countWaysToReachTop(numSteps) {
if (numSteps < 0) {
return 0; // Negative steps are not possible
}
 
if (numSteps === 0 || numSteps === 1) {
return 1; // Base cases: 1 way to reach 0 or 1 step
}
 
// Recursively calculate the number of ways to reach the top
return countWaysToReachTop(numSteps - 1) + countWaysToReachTop(numSteps - 2);
}
 
// Example usage:
const numSteps = 4; // Change this to the desired number of steps
const ways = countWaysToReachTop(numSteps);
 
console.log(`Number of ways to reach the top with ${numSteps} steps: ${ways}`);
 
 
 
16.Write a program to find Maximum subarray in a given array.
 
function maxSubarray(arr) {
if (arr.length === 0) {
return 0; // Empty array
}
 
let maxEndingHere = arr[0];
let maxSoFar = arr[0];
 
for (let i = 1; i < arr.length; i++) {
maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
maxSoFar = Math.max(maxSoFar, maxEndingHere);
}
 
return maxSoFar;
}
 
// Example usage:
const array = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
const maxSum = maxSubarray(array);
 
console.log(`Maximum subarray sum: ${maxSum}`);
 
 
 
17.Write a program to find Minimum number of jumps to reach end.
 
 
function minJumpsToReachEnd(arr) {
const n = arr.length;
if (n <= 1) {
return 0; // No jumps needed for an empty or one-element array
}
 
// Initialize an array to store the minimum jumps required to reach each position
const minJumps = new Array(n).fill(Number.MAX_SAFE_INTEGER);
minJumps[0] = 0; // No jumps needed to start from the first position
 
for (let i = 1; i < n; i++) {
for (let j = 0; j < i; j++) {
if (j + arr[j] >= i) {
// If jumping from position j, we can reach or go beyond position i
minJumps[i] = Math.min(minJumps[i], minJumps[j] + 1);
}
}
}
 
return minJumps[n - 1];
}
 
// Example usage:
const array = [2, 3, 1, 1, 4];
const minJumps = minJumpsToReachEnd(array);
 
console.log(`Minimum number of jumps to reach the end: ${minJumps}`);
 
 
 
18.Write a program to implement Quick Sort
 
function quickSort(arr) {
if (arr.length <= 1) {
return arr;
}
 
const pivot = arr[0];
const left = [];
const right = [];
 
for (let i = 1; i < arr.length; i++) {
if (arr[i] < pivot) {
left.push(arr[i]);
} else {
right.push(arr[i]);
}
}
 
return [...quickSort(left), pivot, ...quickSort(right)];
}
 
// Example usage:
const unsortedArray = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
const sortedArray = quickSort(unsortedArray);
 
console.log('Sorted Array:', sortedArray);
 
 
 
19.Write a program to implement Merge Sort.
 
function mergeSort(arr) {
if (arr.length <= 1) {
return arr;
}
 
const middle = Math.floor(arr.length / 2);
const left = arr.slice(0, middle);
const right = arr.slice(middle);
 
return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
let result = [];
let leftIndex = 0;
let rightIndex = 0;
 
while (leftIndex < left.length && rightIndex < right.length) {
if (left[leftIndex] < right[rightIndex]) {
result.push(left[leftIndex]);
leftIndex++;
} else {
result.push(right[rightIndex]);
rightIndex++;
}
}
 
return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}
 
// Example usage:
const unsortedArray = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
const sortedArray = mergeSort(unsortedArray);
 
console.log('Sorted Array:', sortedArray);
 
 
 
 
20.Write a program to implement Tower of Hanoi problem
 
function towerOfHanoi(n, source, auxiliary, destination) {
if (n === 1) {
console.log(`Move disk 1 from ${source} to ${destination}`);
return;
}
 
towerOfHanoi(n - 1, source, destination, auxiliary);
console.log(`Move disk ${n} from ${source} to ${destination}`);
towerOfHanoi(n - 1, auxiliary, source, destination);
}
 
// Example usage:
const numberOfDisks = 3;
towerOfHanoi(numberOfDisks, 'A', 'B', 'C');
 
 
 
21.Write a program to generate sequence of Fibonacci numbers using Dynamic
Programming
 
 
function generateFibonacciSequence(n) {
if (n <= 0) {
return [];
}
 
const fibSequence = [0, 1];
 
for (let i = 2; i < n; i++) {
const nextFib = fibSequence[i - 1] + fibSequence[i - 2];
fibSequence.push(nextFib);
}
 
return fibSequence;
}
 
// Example usage:
const n = 10; // Change this to the desired number of Fibonacci numbers
const fibonacciSequence = generateFibonacciSequence(n);
 
console.log('Fibonacci Sequence:', fibonacciSequence);
 
 
 
22.Write a program to count all possible unique paths from top left to bottom right of
a mXn matrix.
 
function uniquePaths(m, n) {
if (m === 0 || n === 0) {
return 0;
}
 
// Create a 2D array to store the number of unique paths for each cell
const dp = new Array(m).fill().map(() => new Array(n).fill(1));
 
// Calculate the number of unique paths for each cell in the matrix
for (let i = 1; i < m; i++) {
for (let j = 1; j < n; j++) {
dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
}
}
 
return dp[m - 1][n - 1];
}
 
// Example usage:
const m = 3; // Number of rows
const n = 7; // Number of columns
const paths = uniquePaths(m, n);
 
console.log(`Number of unique paths in a ${m}x${n} matrix: ${paths}`);
 
 
 
 
23.Write a program to print LCS (Longest Common Subsequence)
 
function longestCommonSubsequence(str1, str2) {
const m = str1.length;
const n = str2.length;
const dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));
 
for (let i = 1; i <= m; i++) {
for (let j = 1; j <= n; j++) {
if (str1[i - 1] === str2[j - 1]) {
dp[i][j] = dp[i - 1][j - 1] + 1;
} else {
dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
}
}
}
 
let lcs = '';
let i = m, j = n;
 
while (i > 0 && j > 0) {
if (str1[i - 1] === str2[j - 1]) {
lcs = str1[i - 1] + lcs;
i--;
j--;
} else if (dp[i - 1][j] > dp[i][j - 1]) {
i--;
} else {
j--;
}
}
 
return lcs;
}
 
// Example usage:
const str1 = 'ABCD';
const str2 = 'ACDF';
const lcs = longestCommonSubsequence(str1, str2);
 
console.log('Longest Common Subsequence:', lcs);
 
 
 
24.Write a program to display Power Set of a given set using backtracking approach.
 
function powerSet(inputSet) {
const result = [];
const backtrack = (subset, index) => {
result.push(subset.slice()); // Add the current subset to the result
for (let i = index; i < inputSet.length; i++) {
subset.push(inputSet[i]);
backtrack(subset, i + 1); // Recursively explore subsets
subset.pop(); // Backtrack by removing the last element
}
};
 
backtrack([], 0); // Start with an empty subset at index 0
return result;
}
 
// Example usage:
const inputSet = [1, 2, 3];
const subsets = powerSet(inputSet);
 
console.log('Power Set:', subsets);
 
